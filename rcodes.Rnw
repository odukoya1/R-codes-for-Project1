\documentclass{article}

\begin{document}
\section*{1a}
<<>>=
# Parameters for the Binomial distribution
n <- 10
p <- 1/3

# Inversion method to generate samples
binominverse <- function(n, p, samplenum) {
  generate_samples <- numeric(samplenum)
  for (j in 1:samplenum) {
    u <- runif(1)  # Generate a random number from U(0, 1)
    cdf <- 0
    for (k in 0:n) {
      cdf <- cdf + dbinom(k, n, p)
      if (cdf >= u) {
        generate_samples[j] <- k
        break
      }
    }
  }
  return(generate_samples)
}

# Generate 1000 samples using the inversion method
set.seed(123)  # For reproducibility
sample_inverse <- binominverse(n, p, 1000)
par(mfrow=c(1,1))
# Plot the histogram
hist(sample_inverse, breaks=seq(-0.5, 10.5, 1), prob=TRUE, 
     main=" Inversion Method of 1000 Samples from Binomial(10, 1/3)",
     xlab="Number of successes", col="blue", border="black")
box()
# Calculate the true Binomial probabilities for each possible outcome
x_values <- 0:n  # Possible values of the binomial random variable
binom_pmf <- dbinom(x_values, size = n, prob = p)

# Overlay the binomial PMF as points and lines
points(x_values, binom_pmf, col = "red", pch = 16)  # Red points for the PMF
lines(x_values, binom_pmf, col = "red", lwd = 2)    # Red line connecting the points




@

\section*{1b}


<<>>=

<<>>=
# Set seed for reproducibility
set.seed(123)

# Function to sample from a Bernoulli(p) distribution
bernoulli <- function(p) {
  return(ifelse(runif(1) < p, 1, 0))
}

# Function to sample from Binomial(10, 1/3) using the transformation method
transform_binom <- function(n, p) {
  sum(replicate(n, bernoulli(p)))
}

# Generate 1000 samples using the transformation method
num_sample <- 1000
samples_trans <- replicate(num_sample, transform_binom(10, 1/3))

# Plot the histogram of samples generated by the transformation method
hist(samples_trans, breaks=seq(-0.5, max(samples_transformation)+0.5, by=1), freq=FALSE,
     main="Histogram of 1000 Samples (Transformation Method)",
     xlab="Number of Successes", col="lightgreen", border="black")
box()
# Overlay the true binomial PMF for comparison
x_values <- 0:10
binom_pmf <- dbinom(x_values, size=10, prob=1/3)
points(x_values, binom_pmf, col="red", pch=16)
lines(x_values, binom_pmf, col="red", lwd=2)


@

\section*{1b 2}
<<>>=
# Define the parameters for the Binomial distribution
n <- 10
p <- 1/3

# Function to generate samples using the inversion and transformation methods
binom_sample <- function(n, p, samplenum) {
  samples <- numeric(samplenum)
  
  for (j in 1:samplenum) {
    # Simulate n Bernoulli trials with success probability p
    trials_bernoulli <- runif(n) < p
    samples[j] <- sum(trials_bernoulli)  # Count the number of successes
  }
  
  return(samples)
}

# Generate 1000 samples from Binomial(10, 1/3)
set.seed(123)
samplenum <- 1000
samples <- binom_sample (n, p, samplenum)

# Plot histogram of the samples
hist(samples, probability = TRUE, breaks=seq(-0.5, max(samples_transformation)+0.5, by=1), main = "Histogram of 1000 Samples (Transformation Method)",
     xlab = "Number of successes", col = "lightblue", border = "black")
box()
# Overlay the true binomial probability mass function


x_values1 <- 0:10
binom_pmf <- dbinom(x_values1, size=10, prob=1/3)
points(x_values1, binom_pmf, col="red", pch=16)
lines(x_values1, binom_pmf, col="red", lwd=2)

@

\section*{1C}



<<>>=
# Step 1: Generate 100 samples from the Binomial(10, 1/3) distribution
set.seed(123)
n <- 10
p <- 1/3
samplenum <- 100

# Generate the samples using the inversion and transformation method
samples <- binom_sample (n, p, samplenum)

# Step 2: Estimate the sample mean
sample_mean1 <- mean(samples)

# Step 3: Calculate the standard error
sample_sd1 <- sd(samples)
standard_error1 <- sample_sd1 / sqrt(samplenum)

# Step 4: Compute the 95% confidence interval using the critical value z = 1.96
z_value <- 1.96
lower_bound <- sample_mean1 - z_value * standard_error1
upper_bound <- sample_mean1 + z_value * standard_error1

# Display the results
cat("Estimated Expectation:", sample_mean1, "\n")
cat("Standard Error:", standard_error1, "\n")
cat("95% Confidence Interval: [", lower_bound, ",", upper_bound, "]\n")

# Histogram of the 100 samples
hist(samples, probability = TRUE, breaks = 0:(n+1), main = "Histogram of 100 Binomial(10, 1/3) Samples",
     xlab = "Number of successes", col = "lightblue", border = "black")
box()




@


\section*{Question 2}



<<>>=


 
#Function to draw Poisson(t) samples using the transformation method
pois_trans <- function(t, samplenum) {
  samples <- numeric(samplenum) # initialize a vector to store samples
  for (j in 1:samplenum) {
    n <- 0
    I <- 0
    while (I <= t) {
      # Generate Exponential(1) random variable
      U <- runif(1)
      X <- -log(U)
      I <- I + X
      if (I <= t) {
        n <- n + 1
      }
    }
    samples[j] <- n
  }
  return(samples)
}

# Function to estimate mean and calculate standard error and confidence bounds
estimate_mean <- function(samples) {
  mean_val <- mean(samples)
  std_error <- sd(samples) / sqrt(length(samples))
  # 95% confidence interval (using normal approximation)
  conf_interval <- c(mean_val - 1.96 * std_error, mean_val + 1.96 * std_error)
  return(list(mean = mean_val, std_error = std_error, conf_interval = conf_interval))
}

# Parameters
t <- 1  # Poisson(1) rate parameter
samples_size <- c(10, 100, 1000, 10000)  # Different sample sizes

# Generate samples, plot histograms, and compute mean and confidence bounds for different sample sizes
for (samplenum in samples_size) {
  samples <- pois_trans(t, samplenum)
  
  # Plot histogram
  hist(samples, breaks = seq(min(samples)-0.5, max(samples)+0.5, by = 1),       col = "lightblue", border = "black", main = paste("Poisson(1) Samples (n =", samplenum, ")"),
       xlab = "Value", freq = FALSE)
  # Add density lines
  x_vals <- 0:max(samples)
  poisson_probs <- dpois(x_vals, lambda)
  lines(x_vals, poisson_probs, type = "l", col = "red", lwd = 2)
  points(x_vals, poisson_probs, col = "red", pch = 16)
  
  
  box()
 
  # Estimate mean and confidence bounds
  estimates <- estimate_mean(samples)
  cat("n_samples =", samplenum, ":\n")
  cat("Estimated Mean =", estimates$mean, "\n")
  cat("Standard Error =", estimates$std_error, "\n")
  cat("95% Confidence Interval =", estimates$conf_interval, "\n\n")
}




@



\section*{Question 3a}




<<echo=FALSE>>=
# Define target density: mixture of N(1, 0.5) and N(2, 0.1)
target_pdf <- function(x) {
  0.2 * dnorm(x, mean = 1, sd = sqrt(0.5)) + 0.8 * dnorm(x, mean = 2, sd = sqrt(0.1))
}

# Proposal density: N(1.8, sqrt(0.18))
proposal_pdf <- function(x) {
  dnorm(x, mean = 1.8, sd = sqrt(0.18))
}

# Rejection sampling
rejection_sampling <- function(samplenum) {
  samples <- numeric(samplenum)
  count_accepted <- 0
  M <- 1.5  # Chosen scaling constant to ensure f(x) <= M * g(x)

  j <- 1
  while (j <= samplenum) {
    z <- rnorm(1, mean = 1.8, sd = sqrt(0.18))  # Draw from proposal
    u <- runif(1)  # Uniform(0, 1) random number for acceptance
    if (u < target_pdf(z) / (M * proposal_pdf(z))) {
      samples[j] <- z
      j <- j + 1
      count_accepted <- count_accepted + 1
    }
  }
  acceptance_rate <- count_accepted / (samplenum * M)
  return(list(samples = samples, acceptance_rate = acceptance_rate))
}

# Draw 1000 samples and compute acceptance rate
set.seed(123)
result <- rejection_sampling(1000)
hist(result$samples, probability = TRUE, main = "Rejection Sampling of Mixture of Normals")
curve(0.2 * dnorm(x, 1, sqrt(0.5)) + 0.8 * dnorm(x, 2, sqrt(0.1)), col = "red", add = TRUE)
box()
cat("Acceptance Rate: ", result$acceptance_rate, "\n")



@



\section*{Composition Method}
<<echo=FALSE>>=
# Composition method
composition_sampler <- function(n) {
  samples <- numeric(n)
  for (j in 1:n) {
    if (runif(1) < 0.2) {
      samples[j] <- rnorm(1, mean = 1, sd = sqrt(0.5))  # From N(1, 0.5)
    } else {
      samples[j] <- rnorm(1, mean = 2, sd = sqrt(0.1))  # From N(2, 0.1)
    }
  }
  return(samples)
}

# Generate 1000 samples using the composition method
set.seed(123)
samples_composition <- composition_sampler(samplenum)

# Plot histogram of samples
hist(samples_composition, breaks=30, col="lightgreen", probability=TRUE,
     main="Composition Method - Mixture of Normals", xlab="x", ylab="Density")
box()
# Add the true target density curve
curve(target_pdf(x), col="red", lwd=2, add=TRUE)


@



\section*{Question 3b}


<<>>=
# Define the target pdf for X = Y + a, where Y ~ Exponential(lambda)
target_pdf_b <- function(x, lambda, a) {
  if (x >= a) {
    return(lambda * exp(-lambda * (x - a)))
  } else {
    return(0)
  }
}

# Proposal distribution: Exponential(lambda)
proposal_pdf_b <- function(x, lambda) {
  if (x >= 0) {
    return(lambda * exp(-lambda * x))
  } else {
    return(0)
  }
}

# Draw samples from the proposal distribution (Exponential(lambda))
proposal_sample_b <- function(n, lambda) {
  rexp(n, rate = lambda)
}

# Rejection sampling for X = Y + a
rejection_sampling_b <- function(n, lambda, a) {
  samples <- numeric(n)
  count <- 0
  M <- exp(lambda * a) # M is derived from the maximum ratio of target to proposal
  
  for (i in 1:n) {
    accepted <- FALSE
    while (!accepted) {
      y <- proposal_sample_b(1, lambda)
      u <- runif(1)
      if (u < target_pdf_b(y + a, lambda, a) / (M * proposal_pdf_b(y, lambda))) {
        samples[i] <- y + a
        accepted <- TRUE
        count <- count + 1
      }
    }
  }
  return(list(samples = samples, acceptance_rate = count / n))
}

# Parameters
lambda <- 1
a_values <- c(1, 2, 5)

# Draw samples and check efficiency for different values of a
for (a in a_values) {
  set.seed(123)
  result <- rejection_sampling_b(10000, lambda, a)
  
  # Plot histogram of the results
  hist(result$samples, prob = TRUE,  main = paste("Rejection Sampling for X = Y +", a), col = "lightblue")
  curve(lambda * exp(-lambda * (x - a)), col = "red", add = TRUE)
  box()
  # Print acceptance rate
  cat("For a =", a, "the acceptance rate is", result$acceptance_rate, "\n")
}


@




\end{document}
